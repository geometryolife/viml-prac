# Notes

## Hello World

### 正规派：建立脚本文件

`finish` 表示直接结束脚本，在之后的语句都不再被 Vim 解析；这是可选的，没有遇到 `finish` 就会执行到文件最后一行。

当有了 `*.vim` 脚本文件，就可以在 Vim 环境中用 `:source` 命令加载运行了：

```vim
:source ~/viml-prac/ch1/hello1.vim
```

需要将脚本文件的路径写在 `:source` 命令之后作为参数。如果当前 Vim 正常编辑 *hello1.vim* 这个文件，则可用 `%` 表示当前文件的路径：

```vim
:source %
:so
```

如果还想更省键，就定义一个快捷键映射吧，比如：

```vim
:nnoremap <F5> :update<CR>:source %<CR>
```

可以将这行定义加入你的 `vimrc` 中，不过最好是放在 *~/.vim/ftplugin/vim.vim* 中，并加上局部参数，让它只影响 `*.vim` 文件：

```vim
: nnoremap <buffer> <F5> :update<CR>:source %<CR>
```

### 测试派：进入 Ex 模式

直接在命令行用 `:echo` 查看一些东西其实很有用的，可以快速验证一些记不清楚的细节。比如你想确认下在 VimL 中字符 '0' 是不是与数字 0 相等，可以这样：

```vim
:echo '0' == 0
```

但如果要连续输入多条命令并查看结果，每次都要（从普通模式）先输入个冒号，不免有 些麻烦。
这时，Ex 模式就有用了。默认情况下（若未在 vimrc 被改键映射），在普通模式下用 `Q` 键进入 Ex 模式。
例如，在 Ex 模式下尝试各种输出 “Hell World” 的写法，看看不同引号对结果的影响：

```vim
Entering Ex mode.  Type "visual" to go to Normal mode.
:echo 'Hello World!'
:echo "Hello World!"
:echo 'Hello \t World! \n Hello \t World!'
:echo "Hello \t World! \n Hello \t World!"
:vi
```

最后，按提示用 `visual` 或简写 `vi` 命令回到普通模式。

Vim 的 Ex 模式有点像 VimL 的交互式的解释器，不过语法完全一样（有些脚本语言的*交互式解释器*与*执行脚本*有些不同的优化），仍然要用 `echo` 显示变量的值。

### 索隐派：从 shell 直接运行

如果只为了运行一个 VimScript 脚本，也不一定要先启动 Vim 再 `source`，直接在启动 Vim 时指定特定参数也能办到。
`-e` 参数表示以 Ex 模式启动 Vim，`-S` 参数启动后立即 `source` 一个脚本。因此，也可以用如下的命令来输出 “Hello World”：

```vim
$ cd ~/viml-prac/ch1/hello1.vim
$ vim -eS hello1.vim
```

这就相当于使用 Vim 解释器来运行 *hello.vim* 这个脚本，并且停留在交互式界面上。
此时可以用 `:q` 命令退出，或 `:vi` 以正常方式继续使用 Vim。

Vim 本身的命令行启动参数其实还支持很多功能，请查阅 `:help starting`。
其中还有个特殊的参数是 `-s`，如果与 `-e` 联用，就启动*静默的批处理模式*，试试这个：

```vim
$ vim -eS hello1.vim -s
```

没有任何反应输出？因为 `-s` 使普通的 `echo` 提示无效，看不到任何提示！
赶紧输入 `q` 回车退出 Vim 回到 shell。因为如果不小心按了其他键，Vim 可能就将其当作命令来处理了，而且不会有任何错误提示，这就会让大部分人陷入不知如何退出 Vim 的恐慌。

虽然 `vim -e -s` 不适合来输出 “Hello World”，但如果你的脚本不是用来做这种无聊的任务，这种模式还是有用的。
比如批处理，在完全不必启动 Vim 可视编辑的情况下，批量地对一个文件或多个文件执行编辑任务。
可达到类似 `sed` 的效果。而且，在 Vim 脚本写好的情况下，不仅可以按批处理模式执行，也可以在正常 Vim 可视编辑某个文件时，遇到类似需求时，也可以再手动 `:source` 脚本处理。

## VimL 语言主要特点

### 同源 ex 命令行

那么，VimL 到底是种什么样的语言。这里先说结论吧，VimL 就是富有程序流程控制的 `ex` 命令。用个式子来表示就是：

```text
VimL = ex 命令 + 流程控制
```

VimL 源于 ex ，基于 ex，即使它后来加了很多功能，也始终兼容 ex 命令。

按冒号进入命令行后，再按 `<Ctrl-F>` 将打开一个命令行窗口，里面记录着刚才输入的 ex 历史命令。
这个命令窗口的设计用意是为了便于重复执行一条历史命令，或在某条历史命令的基础上小修后再执行。
不过现在我们要做的是将刚才输入的两条命令保存到一个 文件中，比如就叫 vimrc.vim，整个按键序列是：

```vim
:<Ctrl-F>
Vk
:'<, '> w vimrc.vim<CR>
:q<CR>
```

解释一下：进入命令窗口后光标自动在最后一行，`V` 表示进入行选择模式，`k` 上移一 行，即选择了最后两行。在选择模式下按 `:` 进入命令行，会自动添加 `'<, '>`，这是 特殊的行地址标记法，表示选区，然后用 `:w` 命令将这两行写入 *vimrc.vim* 文件。
最后的 `:q` 命令只是退出命令窗口，但 Vim 仍处于编辑 *helloworld.txt* 状态中。

`:e #` 或快捷键 `<Ctrl-^>` 表示切换到最近编辑的另一个文件。

关于 Vim “命令” 这个名词，还有一点要区分。普通模式下的按键也叫“命令”，可称之为 “普通命令”，但由于普通模式是 Vim 的主模式，所以“普通命令”也往往简称为“命令”了 。通过冒号开始输入而用回车结束输入的，叫 "ex 命令"，Vim 脚本文件不外是记录 “ex 命令”集。（注：宏大多是记录普通命令）

### 默认 vimrc 位置

如何配置 vimrc 属于使用 Vim 的知识（或经验）范畴，不是本 VimL 教程的重点。不过 为了说明 VimL 的特点，也给出一个简单的示例框架如下：

```vim
" File: ~/.vim/vimrc

let $VIMHOME = $HOME . '/.vim'
if has('win32') || has ('win64')
    let $VIMHOME = $VIM . '/vimfiles'
endif

source $VIMHOME/setting.vim
source $VIMHOME/remap.vim
source $VIMHOME/plug.vim

if has('gui')
    " source ...
endif

finish
let $USER = 'vimer'
echo 'Hello ' . $USER '! Working on: ' . strftime("%Y-%m-%d %T")
```

一般地，一份 vimrc 配置包括选项设置，快捷键映射，插件加载等几部分，每部分都可 能变得复杂起来，为方便管理，可以分别写在不同的 vim 脚本中，然后在主 vimrc 脚本 中用 `:source` 命令调用。这就涉及脚本路径全名问题了，若期望能跨平台，就可创建一个变量，根据运行平台设置不同路径，这就用到了 `:if` 分支命令了。

最后两行打印个欢迎词。你可以将自己的大名赋给变量 `$USER`。如果，你觉得这很傻很天真，可以移到 `finish` 之后就不生效了。

在 vimrc 中，选择分支可能很常见，根据不同环境加载合适的配置嘛。但循环就很少见了。因为 vim 向来还有个追求是小巧，启动快，那么你在启动脚本中写个循环是几个意思啊，万一写个死循环 BUG 还启不起来了。

### 流程控制语句也是 ex 命令

在 VimL 中，每一行都是 ex 命令。作为一门脚本语言，最常见的，创建变量要用 `:let` 命令，调用函数要用 `:call` 命令。
初学者最易犯与迷惑的错误，就是忘了 `let` 或 `call`，裸用变量，裸调函数，比如：

```vim
i = -1
abs(-1)
```

用过其他语言的可能会觉得这很自然，但在 VimL 中是个错误，因为它要求第一个词是钦定的 ex 命令！正确的写法是：

```vim
let i = -1
call abs(-1)
```

关键词、命令等可以简写，就与替换命令 `:substitute` 简写为 `:s`，设置命令 `:set` 简写为 `:se` 一样一样的。
但是，在写脚本时，强烈建议都写命令全称。命令简写只为在命令行中快速输入，而在脚本中只要输入一次，一劳永逸，就应以可读性为重了。

当有了这个意识，VimL 的一些奇怪语法约定，也就显得容易理解多了。比如：

* `ex` 命令以回车结束，所以 VimL 语句也按行结束，不要在末尾加分号，加了反而是语 法错误，在 Vim 中每个符号都往往有奇葩意义。
* VimL 的续行符 `\` 写在下一行的开始，其他一些语言是把 `\` 写在上一行结束，表示转义掉换行符，合为一行。但在 VimL 中，每一行都需要一个命令，你可以把 `\` 想象为一个特殊命令，意思是“合并到上一行”。
* 在 VimL 中，不推荐在一行写多个语句，要写也可以，把反斜杠 `\` 扶正为竖线 `|` 表示语句分隔。
这在 Vim 下临时手输单行命令时可能较为常见，减少额外按回车与冒号。在很多键盘布局中，`|`（与 `\`）恰好在回车键上面。

### 关键命令列表

Vim 的 ex 命令集是个很大的集合，比绝大多数的语言的关键字都多一个数量级。
幸运 的是，我们写 VimL 语言的脚本，并不需要掌握或记住这所有的命令，只要记住一些主要 的关键命令就可以完成大部分需求了。

我从 VimL 语言的角度，按常用度与重要度并结合功能性将那些主要的命令分类如下， 仅供参考：

1. let call (unlet)
2. if for while function try (endif, endfor, end...)
3. break continue return finish
4. echo echomsg echoerr
5. execute normal source
6. set map command
7. augroup autocmd
8. wincmd tabnext
9. 其他着重于编辑功能的命令

其中，第 5 类恰好是个分界线，之上的是形成 VimL 语言的关键命令，之下是作为 Vim 编辑器的重要命令。
没有后面的编辑器命令，纯 VimL 语言也可以写脚本，作为一种（没有什么优势的）通用脚本而已；只有利用后面的编辑器命令，才可以调控 Vim。

后面的编辑器命令也可以单独使用，所以 Vim 高手也未必一定需要会 VimL。
不过有了 VimL 语言命令的助力，那些编辑器命令可变得更高效与灵活。
不过最后一大类纯编辑命令，可能较少出现在 VimL 语言脚本中。因为按 Vim 可视化编辑的理念，是需要使用者对这些编辑结果作出及时反馈的。
同时，很多编辑命令也有相应的函数，在 VimL 中调用函数，可能更显得像脚本语言。所以，VimL 中不仅有“库函数”的概念，还有“库命令”呢 。

总之，语句与命令，是联结 VimL 与 Vim 的重要纽带。这是 VimL 语言的重要特点，也是初学者的一大疑难点。尤其是对有其他语言编程经验的，可能还需要一定的思维转换过程吧。

### 弱类型强作用域

“弱类型”不是 VimL 的特点，是几乎所有脚本语言的特点。准确地说是变量无类型，但值 有类型。
创建变量时不必定义类型，直接赋值就行，也可以认为是变量临时获得了值的类 型。关于 VimL 的变量与类型，将在下一章的基础语法中详解。

变量作用域是编程的另一个重要概念，也几乎每个语言都要管理的任务。这里说 VimL 具 有“强作用域”的特点，是指它提供了一种简明的语法，让用户强调变量的作用域范围。

### VimL 语言级的作用域 g: l: s: a:

变量作用域的意义是指该变量在什么范围内可见，可被操作（读值或赋值）。在 VimL 中 ，每个变量都可以加上一个冒号前缀，表示该变量的作用域。不过另有两条规则：

1. 在一些上下文环境中，可以省略作用域前缀，等效于加上了默认的作用域前缀
2. 有一些作用域前缀只在特定的上下文环境中使用。

从 VimL 语言角色看，主要有以下几种作用域：

- `g:` 全局作用域。全局变量就是在当前 Vim 会话环境中，在任何脚本，任何 ex 命 令行中都可以引用的变量。所有在函数之外的命令语句，都默认是全局变量。
- `l:` 局部作用域。只可在当前执行的函数体内使用的变量，在函数体内的变量默认为局部变量，`l:` 局部变量也只能在函数体内使用。
- `s:` 脚本作用域。只有当前脚本内可引用的变量，包括该脚本的函数体内。
- `a:` 参数作用域。特指函数的参数，在函数体内，要引用传入的实参，就得加上 `a:` 前缀，但定义函数时的形参，不能加 `a:` 前缀。`a:` 还隐含一个限定是只读性，即不能在函数体内修改参数。

这几种作用域前缀所对应的英文单词，可认为是 global，local，script 与 argument。不过 `s:` 也可认为是 static，因为在 C 语言中，static 也表示只在当前文件中有效的意思。

**变量作用域的应用原则：**

1. 尽量少用全局变量，因为容易混乱使用，难于管理。不过在 ex 命令行或 Ex 模式下 只为临时测试的语句，为了方便省略前缀，是全局变量，当然在此命令中也只能是全局变量。在写 vim 脚本文件时，若要使用全局变量，不要省略 `g:` 前缀。同时全局 变量名尽量取得特殊点，比如全是大写，或带个插件名的长变量名，以减少被冲突的概率。
2. 局部变量的前缀 `l:` 一般可省略。但我建议也始终加上，虽然多敲了两个字符，但编程的效率来源于思路清晰，不在于少那几个字符。同时在 VimL 编程时，坚持习 惯了作用域前缀，就能在头脑中无形地加强这种意识，然后对作用域的把握也更加精准。另外，显然地，在函数体内要引用全局就是必须加上 `g:` 前缀。
3. 在写 Vim 脚本时，函数外的代码，能用 `s:` 变量就尽量用 `s:` 变量。对于比较大的脚本变量（如字典），想对外分享，也宁可先定义为 `s:` 变量，再定义一个全局可访问的函数来返回这个脚本变量。
4. 参数变量，`a:` 是语法强制要求，漏写了 `a:` 往往是个错误，（如果它没报错，恰好与同名局部变量冲突了，那是更糟糕与难以觉察的错误）也是初写 VimL 函数最容易犯的语法错误。
